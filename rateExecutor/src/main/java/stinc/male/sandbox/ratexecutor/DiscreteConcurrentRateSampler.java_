package stinc.male.sandbox.ratexecutor;

import java.time.Duration;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.Nullable;
import javax.annotation.concurrent.ThreadSafe;
import static stinc.male.sandbox.ratexecutor.Preconditions.checkArgument;

@ThreadSafe
public final class DiscreteConcurrentRateSampler extends AbstractRateSampler {
  private final AtomicLong aTicksTotalCount;
  private final AtomicLong[] samples;
  private volatile long rightIdx;
  private final long sampleStepNanos;
  private final AtomicBoolean aStepFlag;

  /**
   * Constructor.
   *
   * @param startNanos Starting point that is used to calculate elapsed nanoseconds.
   * @param sampleInterval Size of the sample window.
   */
  public DiscreteConcurrentRateSampler(final long startNanos, final Duration sampleInterval, final RateSamplerConfig config) {
    super(startNanos, sampleInterval, config);
    aTicksTotalCount = new AtomicLong();
    this.sampleStepNanos = config.getSampleStep().toNanos();
    final long sampleIntervalNanos = getSampleIntervalNanos();
    final int sampleStepsCountInSampleInterval = (int)(sampleIntervalNanos / sampleStepNanos);
    checkArgument(sampleStepNanos * sampleStepsCountInSampleInterval == sampleIntervalNanos, "config", "Sample interval (%s nanos) must be multiple of sample step (%s nanos)");
    samples = new AtomicLong[sampleStepsCountInSampleInterval];
    for (int idx = 0; idx < samples.length; idx++) {
      samples[idx] = new AtomicLong();
    }
    rightIdx = samples.length - 1;
    aStepFlag = new AtomicBoolean();
  }

  @Override
  public final long rightSampleWindowBoundary() {
    final long rightIdx = this.rightIdx;
    final long shiftSampleIntervalCount = rightIdx / samples.length;
    final long shiftSampleStepCount = rightIdx % samples.length;
    return getSampleIntervalNanos() * shiftSampleIntervalCount + sampleStepNanos * shiftSampleStepCount;
  }

  @Override
  public final long ticksCount() {
    final long rightNanos = rightSampleWindowBoundary();
    return internalCount(rightNanos - getSampleIntervalNanos(), rightNanos);
  }

  @Override
  public final long ticksTotalCount() {
    return aTicksTotalCount.get();
  }

  @Override
  public final void tick(final long count, final long tNanos) {
    final long startNanos = getStartNanos();
    checkArgument(NanosComparator.compare(tNanos, startNanos) >= 0, "tNanos", () -> "Must not be less than " + startNanos);
    checkTNanos(tNanos, "tNanos");
    if (count != 0) {
      final long rightNanos = rightSampleWindowBoundary();
      final long leftNanos = rightNanos - getSampleIntervalNanos();
      if (NanosComparator.compare(leftNanos, tNanos) < 0 && NanosComparator.compare(tNanos, rightNanos) <= 0) {//step is not needed
        final long shiftNanos = tNanos - leftNanos;
        final long shiftSampleStepCount = shiftNanos / sampleStepNanos + 1;
      }
      aTicksTotalCount.addAndGet(count);
    }
  }








  @Override
  public final double rateAverage() {
    return internalRateAverage(samples.lastKey(), getSampleIntervalNanos());
  }

  @Override
  public final double rateAverage(final long tNanos) {
    checkTNanos(tNanos, "tNanos");
    final long rightNanos = samples.lastKey();
    checkArgument(tNanos >= rightNanos, "tNanos", () -> "Must not be less than " + rightNanos);
    return internalRateAverage(tNanos, getSampleIntervalNanos());
  }

  @Override
  public final double rate(final long tNanos) {
    checkTNanos(tNanos, "tNanos");
    return internalRate(tNanos, getSampleIntervalNanos());
  }

  private final double internalRateAverage(final long tNanos, final long unitSizeNanos) {
    final long totalTicksCount = aTicksTotalCount.get();
    final long totalNanos = tNanos - getStartNanos();
    return totalNanos == 0
        ? 0
        : (double) totalTicksCount / ((double) totalNanos / unitSizeNanos);
  }

  private final double internalRate(final long tNanos, final long unitSizeNanos) {
    final double result;
    final long rightNanos = samples.lastKey();
    if (NanosComparator.compare(tNanos, rightNanos) < 0) {
      result = internalRateAverage(tNanos, unitSizeNanos);
    } else {
      final long sampleIntervalNanos = getSampleIntervalNanos();
      final long effectiveRightNanos = NanosComparator.max(rightNanos, tNanos);
      final long effectiveLeftNanos = effectiveRightNanos - sampleIntervalNanos;
      final long ticksCount = internalCount(effectiveLeftNanos, effectiveRightNanos);
      result = (unitSizeNanos == sampleIntervalNanos)
          ? ticksCount
          : (double) ticksCount / ((double) sampleIntervalNanos / unitSizeNanos);
    }
    return result;
  }

  private final long internalCount(final long fromExclusiveNanos, final long toInclusiveNanos) {
    return samples.subMap(fromExclusiveNanos, false, toInclusiveNanos, true)
        .values()
        .stream()
        .mapToLong(AtomicLong::get)
        .reduce(0, Math::addExact);
  }
}