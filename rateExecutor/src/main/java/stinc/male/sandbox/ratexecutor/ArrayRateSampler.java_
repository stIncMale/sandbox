package stinc.male.sandbox.ratexecutor;

import java.time.Duration;
import java.util.concurrent.locks.StampedLock;
import javax.annotation.concurrent.ThreadSafe;
import static stinc.male.sandbox.ratexecutor.Preconditions.checkNotNull;

@ThreadSafe
public class ArrayRateSampler extends AbstractRateMeter {
  private static final int MAX_TRY_LOCK_ATTEMPTS = 3;

  private final TicksCounter[] samples;
  private final long samplesWindowStepNanos;
  private volatile long samplesWindowShiftSteps;
  private final StampedLock moveSamplesWindowLock;

  /**
   * @param startNanos Starting point that is used to calculate elapsed nanoseconds.
   * @param samplesInterval Size of the samples window.
   * @param config Additional configuration parameters.
   * @param granularity
   */
  public ArrayRateSampler(
      final long startNanos,
      final Duration samplesInterval,
      final RateMeterConfig config,
      final Duration granularity) {
    super(startNanos, samplesInterval, config);
    checkNotNull(granularity, "granularity");
    Preconditions.checkArgument(!granularity.isZero(), "granularity", "Must not be zero");
    Preconditions.checkArgument(!granularity.isNegative(), "granularity", "Must be positive");
    this.samplesWindowStepNanos = granularity.toNanos();
    final long samplesIntervalNanos = getSamplesIntervalNanos();
    final int stepsCountInSamplesInterval = (int)(samplesIntervalNanos / samplesWindowStepNanos);
    Preconditions.checkArgument(samplesWindowStepNanos * stepsCountInSamplesInterval == samplesIntervalNanos,
        "granularity", () -> String.format("Samples interval (%s nanos) must be multiple of samples window step (%s nanos)", samplesIntervalNanos, samplesWindowStepNanos));
    samples = new TicksCounter[stepsCountInSamplesInterval];
    for (int idx = 0; idx < samples.length; idx++) {
      samples[idx] = config.getTicksCounterSupplier().apply(0L);
    }
    samplesWindowShiftSteps = 0;
    moveSamplesWindowLock = new StampedLock();
  }

  @Override
  public long rightSamplesWindowBoundary() {
    return samplesWindowShiftSteps * samplesWindowStepNanos;
  }

  @Override
  public long ticksCount() {
    long result;
    long stamp = 0;
    boolean optimistic = true;
    try {
      do {
        result = 0;
        stamp = moveSamplesWindowLock.tryOptimisticRead();
        if (stamp == 0) {//no luck, get read lock
          stamp = moveSamplesWindowLock.readLock();
          optimistic = false;
        }
        for (int idx = 0; idx < samples.length; idx++) {
          result += samples[idx].get();
        }
      } while (!optimistic || !moveSamplesWindowLock.validate(stamp));
    } finally {
      if (!optimistic) {
        moveSamplesWindowLock.unlockRead(stamp);
      }
    }
    return result;
  }

  @Override
  public void tick(final long count, final long tNanos) {
    checkArgument(tNanos, "tNanos");
    if (count != 0) {
      final long rightNanos = rightSamplesWindowBoundary();
      final long leftNanos = rightNanos - getSamplesIntervalNanos();
      if (NanosComparator.compare(leftNanos, tNanos) < 0) {//tNanos is not behind the samples window
        final long samplesWindowShiftSteps = samplesWindowStepNanos;
        final long targetSamplesWindowShiftSteps = (tNanos - getStartNanos()) / samplesWindowStepNanos + 1;
        if (targetSamplesWindowShiftSteps <= samplesWindowShiftSteps) {//no need to move the samples window
          samples[samplesIdx(targetSamplesWindowShiftSteps)].add(count);
        } else {//we need to move the samples window
          moveSamplesWindowLock.try
          this.samplesWindowShiftSteps = targetSamplesWindowShiftSteps;
          final long moveRightSteps = targetSamplesWindowShiftSteps - samplesWindowShiftSteps;
          if (moveRightSteps < samples.length) {//some samples are intact

          } else {//reset all samples
            for (int idx = 0; idx < samples.length; idx++) {
              //reset samples[idx]
            }
          }
        }
      }
      getTicksTotalCounter().add(count);
    }
  }

  @Override
  public double rate(final long tNanos) {
    return 0;
  }

  private final int samplesIdx(final long samplesWindowShiftSteps) {
    return (int)((samplesWindowShiftSteps + samples.length - 1) % samples.length);//the result can not be greater than samples.length, which is int, so it is a safe cast to int
  }

  private static final
}